<h2 id="春秋GAME"><a href="#春秋GAME" class="headerlink" title="春秋GAME"></a>春秋GAME</h2><p>战队名:hash_hash</p>
<p>排名:5</p>
<h3 id="Train"><a href="#Train" class="headerlink" title="Train"></a>Train</h3><p>找到关于自定义哈希函数的碰撞</p>
<pre><code>def TrainHash(msg):
    n = n0
    msg = map(ord,msg)
    for i in msg :
        n = g * (n+i)
        n = n &amp; (1&lt;&lt;383)
    return n - 0xf5e33dabb114514
</code></pre>
<p>碰撞条件</p>
<pre><code>if TrainHash(string1) == TrainHash(string2):
    self.send(b&#39;\nJust do it!~ You can do more!&#39;)
    if string2.encode()[-50:] == string1.encode()[-50:]:
        self.send(flag)
</code></pre>
<p>设碰撞明文ascii码序列为$t_i$及$s_i$</p>
<p>最简单的构造两序列长度一致为l</p>
<p>满足$\sum_{k&#x3D;1}^lg^{l-k}t_k&#x3D;\sum_{k&#x3D;1}^lg^{l-k}s_k(mod~2^{383})$</p>
<p>$&#x3D;&gt;\sum_{k&#x3D;1}^lg^{l-k}(t_k-s_k)&#x3D;0(mod~2^{383})$</p>
<p>最后按照背包的样式造格就行，只需满足系数不太大就能在ascii范围内找到解</p>
<pre><code class="python">n0 = 30798082519452208630254982405300548841337042015746308462162479889627080155514391987610153873334549377764946092629701
g = 64146569863628228208271069055817252751116365290967978172021890038925428672043
mod=2^383
A=[]
for i in range(50):
    A.append(pow(g,50+i,mod))

L=Matrix(51,51)
for i in range(50):
    L[i,50]=2^50*A[i]
    L[i,i]=1
L[50,50]=2^50*2^383
L=L.LLL()
print(L[1])
</code></pre>
<p>ascii码范围内找碰撞</p>
<pre><code class="python">deta=(-62, -28, 6, 54, 62, 65, 8, 15, -27, -13, -55, -15, 34, 34, -46, 0, 0, 33, -4, -70, -30, 54, -10, -50, 33, -55, -73, 76, -5, -31, 17, 36, 77, -37, -35, -9, 53, -27, -42, 26, 24, 18, -55, -5, -17, 55, -42, 14, 17, 0, 0)
s1=&#39;&#39;
s2=&#39;&#39;
for i in range(len(deta)):
    for j in range(40,126):
        if 40&lt;(j+deta[i])&lt;126:
            s1+=chr(j)
            s2+=chr(j+deta[i])
            break
t1=s1+&#39;a&#39;*50
t2=s2+&#39;a&#39;*50
print(t1)
print(t2)
</code></pre>
<h3 id="bob’s-enc"><a href="#bob’s-enc" class="headerlink" title="bob’s enc"></a>bob’s enc</h3><p>flag前一段就是解个矩阵方程，第二段是最简单的lwe加密</p>
<p>1.解矩阵方程</p>
<pre><code>key = 
q=
c1=
A=Matrix(Zmod(q),key)
print(bytes(list(A.solve_right(c1))))
</code></pre>
<p>2.解LWE</p>
<p>由于系数都比较小我直接用的最朴素的babai算法，更糟糕的情况下可以考虑使用最近平面算法</p>
<pre><code>m = 64
n = 21
q = 2141

A = 
A=Matrix(GF(q),A)
c2 = 

L=Matrix(ZZ,m+n,m)
for i in range(m):
    for j in range(n):
        L[j,i]=A[i][j]
for i in range(m):
    L[n+i,i]=q

def babai(A, w):
    A = A.LLL()[21:]
    G = A.gram_schmidt()[0]
    t = w
    for i in reversed(range(A.ncols())):
        c = ((t * G[i]) / (G[i] * G[i])).round()
        t -= A[i] * c
    return w - t

v_e=vector(ZZ,c2)
v=babai(L,v_e)
print(bytes(list(A.solve_right(v))))
</code></pre>
<h3 id="被带走的机密文件"><a href="#被带走的机密文件" class="headerlink" title="被带走的机密文件"></a>被带走的机密文件</h3><p>取证大师新建案例，把镜像导入进去自动分析。</p>
<p>在取证结果里找可疑文件，发现用户痕迹里有打印信息：</p>
<p><img src="C:\Users\86195\AppData\Roaming\Typora\typora-user-images\image-20220507210554927.png" alt="image-20220507210554927"></p>
<p>预览可看到包含flag的文件，放大即可。</p>
<p><img src="C:\Users\86195\AppData\Roaming\Typora\typora-user-images\image-20220507210609218.png" alt="image-20220507210609218"></p>
<h3 id="PINTU"><a href="#PINTU" class="headerlink" title="PINTU"></a>PINTU</h3><p>用某平台大师傅以前造的轮子直接梭，比拼图工具好用，图片尺寸没有太多限制。</p>
<pre><code class="python">import struct
import os,zlib,re,sys
from Crypto.Util.number import *
from PIL import Image
from tqdm import tqdm


def pngparse(filepath1):
    fr=open(filepath1,&#39;rb&#39;).read()

    chunckid=[b&#39;IHDR&#39;,b&#39;PLTE&#39;,b&#39;IDAT&#39;,b&#39;IEND&#39;,b&#39;cHRM&#39;,b&#39;gAMA&#39;,b&#39;iCCP&#39;,b&#39;sBIT&#39;,b&#39;sRGB&#39;,b&#39;bKGD&#39;,b&#39;hIST&#39;,b&#39;tRNS&#39;,b&#39;pHYs&#39;,b&#39;sPLT&#39;,b&#39;tIME&#39;,b&#39;iTXt&#39;,b&#39;tEXt&#39;,b&#39;zTXt&#39;]
    chuncks=[]
    i=4
    while i&lt;len(fr):
        if fr[i:i+4] in chunckid:
            try:
                datalen,dataname=struct.unpack(&quot;&gt;I4s&quot;,fr[i-4:i+4])
                dataformat=&#39;&gt;I4s&#39;+str(datalen)+&#39;s&#39;+&#39;4s&#39;
                datalen,dataname,data,datacrc=struct.unpack(dataformat,fr[i-4:i-4+8+datalen+4])
                realcrc=zlib.crc32(dataname+data).to_bytes(4,&#39;big&#39;)
                if realcrc!=datacrc:
                    datacrc=realcrc
                    print(dataname,&#39;crc32 fixed&#39;)
                # print(datalen,bytes.decode(dataname,encoding=&#39;utf-8&#39;),hex(int.from_bytes(datacrc,&#39;big&#39;)))
                chuncks.append(fr[i-4:i-4+8+datalen]+realcrc)
                i=i+8+datalen+4 #最少加一，防止出现iend
            except: #防止不能解析的结构体中出现png chunckid的关键字，指针直接指向下一个。
                i=i+1
                continue    
        else:
            i=i+1

    idat=[tmp for tmp in chuncks if tmp[4:8]==b&#39;IDAT&#39;]    
    blocks=[tmp[8:int.from_bytes(tmp[:4],&#39;big&#39;)+8] for tmp in chuncks if tmp[4:8]==b&#39;IDAT&#39;]
    blocks=b&#39;&#39;.join(blocks) #组合数据
    data=zlib.decompressobj().decompress(blocks) #解码zlib得到像素（含filter）
    width=bytes_to_long(fr[16:20])
    height=bytes_to_long(fr[20:24])
    colorchannel={0:1,2:3,3:1,4:2,6:4}[bytes_to_long(fr[25:26])] 
    bits=bytes_to_long(fr[24:25])
    perlinebytes=bits*colorchannel*width//8+1 #每行字节数

    filters=[(data[i]) for i in range(0,len(data),perlinebytes)]

    return fr,width,height,colorchannel,bits,perlinebytes,filters

def parseimg(filepath1):
    img=Image.open(filepath1)
    width=img.size[0]
    height=img.size[1]

    if img.mode ==&#39;RGBA&#39;:
        pass
    elif img.mode==&#39;RGB&#39;:
        print(&#39;不含alpha通道，需要将图片转换位RGBA&#39;)
        img = img.convert(&#39;RGBA&#39;)
        # img.save(&#39;test.png&#39;)
    pixel=[]
    for h in range(height):
        for w in range(width):
            color=img.getpixel((w,h))
            r=color[0]
            g=color[1]
            b=color[2]
            a=color[3]
            pixel.append((r,g,b,a))
            # pixel=pixel+&#39;\n&#39;    
        # fw.write(str(pixel))  
        
    def list_split(items, n):  
        return [items[i:i+n] for i in range(0, len(items), n)]    

    scanlines = list_split(pixel, width) 
    return scanlines


def load_imgs(folder):
    imgpath = []
    # img=[]
    for img_path in os.listdir(folder):
        ext = os.path.splitext(img_path)
        # if len(ext) &gt; 1 and is_img(ext[1]):
        if ext[1] == &#39;.png&#39; or ext[1]==&#39;.jpg&#39; or ext[1]==&#39;.bmp&#39;:
            filename=folder+&#39;/&#39;+img_path
            imgpath.append(filename)
            # img.append(img_path)

    return imgpath




def num2filter(pathname):
    pathname=pathname[-8:-4]
    b=[]
    for i in pathname:
        if i ==&#39;1&#39;:
            b.append([4,4,4,4,4])
            b.append([1,1,1,1,1])
        elif i==&#39;2&#39;:
            b.append([4,1,4,4,4])
            b.append([4,4,4,1,4]) 
        elif i==&#39;3&#39;:
            b.append([4,1,4,1,4])
            b.append([4,4,4,4,4])
        elif i==&#39;4&#39;:
            b.append([4,4,4,1,1])
            b.append([4,4,4,4,4])
        elif i==&#39;5&#39;:
            b.append([4,4,4,1,4])
            b.append([4,1,4,4,4])
        elif i==&#39;6&#39;:
            b.append([4,4,4,4,4])
            b.append([4,1,4,4,4])
        elif i==&#39;7&#39;:
            b.append([4,1,1,1,1])
            b.append([4,4,4,4,4])  
        elif i==&#39;8&#39;:
            b.append([4,4,4,4,4])
            b.append([4,4,4,4,4])  
        elif i==&#39;9&#39;:
            b.append([4,4,4,1,4])
            b.append([4,4,4,4,4])   
        elif i==&#39;0&#39;:
            b.append([0,0,0,0,0])
            b.append([0,0,0,0,0])    
    # print(b)
    # t=[]
    t=&#39;&#39;
    for i in range(0,5):
        # t.append([x[i] for x in b])
        # t1=[str(x[i]) for x in b]
        for x in b:
            t+=str(x[i])
        
    print(t)
    
    return t

def filter2num(myfilters):
    myft=[myfilters[i:i+8] for i in range(0,len(myfilters),8)]

    b=[]
    for i in range(0,8,1):
        
        b.append([int(x[i]) for x in myft])


    c=&#39;&#39;
    for t in range(0,8,2): 
        if b[t]==[4,4,4,4,4] and b[t+1]==[1,1,1,1,1]:
            c+=&#39;1&#39;
        elif b[t]==[4,1,4,4,4] and b[t+1]==[4,4,4,1,4]: 
            c+=&#39;2&#39;   
        elif b[t]==[4,1,4,1,4] and b[t+1]==[4,4,4,4,4]: 
            c+=&#39;3&#39;
        elif b[t]==[4,4,4,1,1] and b[t+1]==[4,4,4,4,4]: 
            c+=&#39;4&#39;
        elif b[t]==[4,4,4,1,4] and b[t+1]==[4,1,4,4,4]:  
            c+=&#39;5&#39;  
        elif b[t]==[4,4,4,4,4] and b[t+1]==[4,1,4,4,4]:   
            c+=&#39;6&#39;
        elif b[t]==[4,1,1,1,1] and b[t+1]==[4,4,4,4,4]:    
            c+=&#39;7&#39;
        elif b[t]==[4,4,4,4,4] and b[t+1]==[4,4,4,4,4]:  
            c+=&#39;8&#39;
        elif b[t]==[4,4,4,1,4] and b[t+1]==[4,4,4,4,4]:   
            c+=&#39;9&#39;
        elif b[t]==[0,0,0,0,0] and b[t+1]==[0,0,0,0,0]:      
            c+=&#39;0&#39;
        else:
            print(&#39;maybe not a number&#39;)
    print(c)
    return c


def filter0_none(scanlines,colorchannel,bits,width,tmp,row):
    data=[long_to_bytes(i[0])+long_to_bytes(i[1])+long_to_bytes(i[2])+long_to_bytes(i[3]) for i in scanlines[row] ]
    return b&#39;\x00&#39;+b&#39;&#39;.join(data)
    
def filter1_sub(scanlines,colorchannel,bits,width,tmp,row):
    data=[scanlines[row][0]]
    for tmp in range(1,width): #注意负数要用反码，和ff与一下即可
        tmp_r=(scanlines[row][tmp][0]-scanlines[row][tmp-1][0])&amp;0xff
        tmp_g=(scanlines[row][tmp][1]-scanlines[row][tmp-1][1])&amp;0xff
        tmp_b=(scanlines[row][tmp][2]-scanlines[row][tmp-1][2])&amp;0xff
        tmp_a=(scanlines[row][tmp][3]-scanlines[row][tmp-1][3])&amp;0xff
        data.append((tmp_r,tmp_g,tmp_b,tmp_a))
    data=[long_to_bytes(i[0])+long_to_bytes(i[1])+long_to_bytes(i[2])+long_to_bytes(i[3]) for i in data ]
    return b&#39;\x01&#39;+b&#39;&#39;.join(data)

def filter2_up(scanlines,colorchannel,bits,width,tmp,row):
    if row==0:
        data=[long_to_bytes(i[0])+long_to_bytes(i[1])+long_to_bytes(i[2])+long_to_bytes(i[3]) for i in scanlines[row] ]
        return b&#39;\x02&#39;+b&#39;&#39;.join(data)
    else :
        data=[]
        for tmp in range(0,width): #注意负数要用反码，和ff与一下即可
            tmp_r=(scanlines[row][tmp][0]-scanlines[row-1][tmp][0])&amp;0xff
            tmp_g=(scanlines[row][tmp][1]-scanlines[row-1][tmp][1])&amp;0xff
            tmp_b=(scanlines[row][tmp][2]-scanlines[row-1][tmp][2])&amp;0xff
            tmp_a=(scanlines[row][tmp][3]-scanlines[row-1][tmp][3])&amp;0xff
            data.append((tmp_r,tmp_g,tmp_b,tmp_a))
        data=[long_to_bytes(i[0])+long_to_bytes(i[1])+long_to_bytes(i[2])+long_to_bytes(i[3]) for i in data ]    
        return b&#39;\x02&#39;+b&#39;&#39;.join(data)

def filter3_average(scanlines,colorchannel,bits,width,tmp,row):
    if row==0:
        data=[scanlines[row][0]]
        for tmp in range(1,width):
            tmp_r=(scanlines[row][tmp][0]-scanlines[row][tmp-1][0]//2)&amp;0xff
            tmp_g=(scanlines[row][tmp][1]-scanlines[row][tmp-1][1]//2)&amp;0xff
            tmp_b=(scanlines[row][tmp][2]-scanlines[row][tmp-1][2]//2)&amp;0xff
            tmp_a=(scanlines[row][tmp][3]-scanlines[row][tmp-1][3]//2)&amp;0xff
            data.append((tmp_r,tmp_g,tmp_b,tmp_a))
        data=[long_to_bytes(i[0])+long_to_bytes(i[1])+long_to_bytes(i[2])+long_to_bytes(i[3]) for i in data ]    
        return b&#39;\x03&#39;+b&#39;&#39;.join(data)    
    else:
        data=[]
        first_r=(scanlines[row][0][0]-scanlines[row-1][0][0]//2)&amp;0xff
        first_g=(scanlines[row][0][1]-scanlines[row-1][0][1]//2)&amp;0xff
        first_b=(scanlines[row][0][2]-scanlines[row-1][0][2]//2)&amp;0xff
        first_a=(scanlines[row][0][3]-scanlines[row-1][0][3]//2)&amp;0xff
        data.append((first_r,first_g,first_b,first_a))

        for tmp in range(1,width):
            tmp_r=(scanlines[row][tmp][0]-(scanlines[row][tmp-1][0]+scanlines[row-1][tmp][0])//2)&amp;0xff
            tmp_g=(scanlines[row][tmp][1]-(scanlines[row][tmp-1][1]+scanlines[row-1][tmp][1])//2)&amp;0xff
            tmp_b=(scanlines[row][tmp][2]-(scanlines[row][tmp-1][2]+scanlines[row-1][tmp][2])//2)&amp;0xff
            tmp_a=(scanlines[row][tmp][3]-(scanlines[row][tmp-1][3]+scanlines[row-1][tmp][3])//2)&amp;0xff
            data.append((tmp_r,tmp_g,tmp_b,tmp_a))
        data=[long_to_bytes(i[0])+long_to_bytes(i[1])+long_to_bytes(i[2])+long_to_bytes(i[3]) for i in data ]    
        return b&#39;\x03&#39;+b&#39;&#39;.join(data)     

def paeth(a,b,c):
    p = a + b - c
    pa = abs(p - a)
    pb = abs(p - b)
    pc = abs(p - c)
    if pa &lt;= pb and pa &lt;= pc :
        Pr = a
    elif pb &lt;= pc :
        Pr = b
    else :
        Pr = c
    return Pr

def filter4_paeth(scanlines,colorchannel,bits,width,tmp,row):    
    if row==0:
        data=[scanlines[row][0]]
        for tmp in range(1,width): #注意负数要用反码，和ff与一下即可
            tmp_r=(scanlines[row][tmp][0]-scanlines[row][tmp-1][0])&amp;0xff
            tmp_g=(scanlines[row][tmp][1]-scanlines[row][tmp-1][1])&amp;0xff
            tmp_b=(scanlines[row][tmp][2]-scanlines[row][tmp-1][2])&amp;0xff
            tmp_a=(scanlines[row][tmp][3]-scanlines[row][tmp-1][3])&amp;0xff
            data.append((tmp_r,tmp_g,tmp_b,tmp_a))
        data=[long_to_bytes(i[0])+long_to_bytes(i[1])+long_to_bytes(i[2])+long_to_bytes(i[3]) for i in data ]
        return b&#39;\x04&#39;+b&#39;&#39;.join(data)   
    else:
        data=[]
        first_r=(scanlines[row][0][0]-scanlines[row-1][0][0])&amp;0xff     
        first_g=(scanlines[row][0][1]-scanlines[row-1][0][1])&amp;0xff
        first_b=(scanlines[row][0][2]-scanlines[row-1][0][2])&amp;0xff
        first_a=(scanlines[row][0][3]-scanlines[row-1][0][3])&amp;0xff
        data.append((first_r,first_g,first_b,first_a))


        for tmp in range(1,width):
            tmp_r=(scanlines[row][tmp][0]-paeth(scanlines[row][tmp-1][0],scanlines[row-1][tmp][0],scanlines[row-1][tmp-1][0]))&amp;0xff
            tmp_g=(scanlines[row][tmp][1]-paeth(scanlines[row][tmp-1][1],scanlines[row-1][tmp][1],scanlines[row-1][tmp-1][1]))&amp;0xff
            tmp_b=(scanlines[row][tmp][2]-paeth(scanlines[row][tmp-1][2],scanlines[row-1][tmp][2],scanlines[row-1][tmp-1][2]))&amp;0xff
            tmp_a=(scanlines[row][tmp][3]-paeth(scanlines[row][tmp-1][3],scanlines[row-1][tmp][3],scanlines[row-1][tmp-1][3]))&amp;0xff
            data.append((tmp_r,tmp_g,tmp_b,tmp_a))
        data=[long_to_bytes(i[0])+long_to_bytes(i[1])+long_to_bytes(i[2])+long_to_bytes(i[3]) for i in data ]

        return b&#39;\x04&#39;+b&#39;&#39;.join(data)


    
    
# fr,width,height,colorchannel,bits,perlinebytes,filters=pngparse(filepath1)

# for numbers in c:
if __name__ == &quot;__main__&quot;:
    im1=Image.new(&#39;RGBA&#39;,(32*120,18*120),&#39;white&#39;)

    path=r&#39;./imgs/&#39;
    pathnames=load_imgs(path)
    for filepath1 in tqdm(pathnames):
        with open(filepath1,&#39;rb&#39;)as f:
            fr=f.read()
        x=int.from_bytes(fr[6:8],&#39;little&#39;)    
        y=int.from_bytes(fr[8:10],&#39;little&#39;)
        im2=Image.open(filepath1)
        im1.paste(im2,(x*32,y*18))
        pass    
    im1.show()
    im1.save(&#39;output.png&#39;)
    pass
   
       
</code></pre>
<p><img src="C:\Users\86195\AppData\Roaming\Typora\typora-user-images\image-20220507210930281.png" alt="image-20220507210930281"></p>
